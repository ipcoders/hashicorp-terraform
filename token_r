---
# =====================================================================
# Remediation Playbook
# - Play 1: IDENTIFY (copy of dryrun Play 1 logic for parity)
# - Play 2: REMEDIATE (ifcfg + dhclient only, no resolv.conf edits)
# =====================================================================

- name: Remediation - Identify (parity with dryrun)
  hosts: all
  serial: 1
  become: true
  become_user: root
  gather_facts: no

  pre_tasks:
    - name: Set Global variables
      ansible.builtin.set_fact:
        resolv_conf_path: "/etc/resolv.conf"
        ifcfg_profile: "../configuration/ifcfg.yml"
        ifcfg_dir: "/etc/sysconfig/network-scripts"

        inventory_zone_found: false
        profile_found: false

        # IMPORTANT: initialize BOTH summaries
        vm_ifcfg_summary: []
        vm_resolv_summary: []

        dns_configs: []
        all_dhclient_files: []
        disable_dhclient: false

        # Track in-scope explicitly for Play 2 gating
        in_scope: false

        # Expected resolvers (same variable name as dryrun)
        valid_nameservers: ["1.1.1.1", "2.2.2.2"]

        # Change tracking (used in Play 2)
        changed_ifcfg: false
        changed_dhclient: false

    - name: Reachability check
      ansible.builtin.wait_for_connection:
        timeout: 10
      register: wfc
      ignore_unreachable: true
      failed_when: false

    - name: Block unreachable/auth failed
      when:
        - wfc is defined and wfc.msg is defined
        - (wfc.msg | regex_search('timed out|time out|failed to connect|unreachable|connection refused|permission denied', ignorecase=True))
      block:
        - name: Error message
          ansible.builtin.debug:
            msg: "The '{{ inventory_hostname }}' VM is unreachable or authentication failed."

        - name: Write failed hosts lists
          ansible.builtin.set_fact:
            in_scope: false
            vm_ifcfg_summary: "{{ vm_ifcfg_summary + [{'host': inventory_hostname, 'msg': 'unreachable_vm'}] }}"

        - meta: end_host

    - name: Include DNS variables
      ansible.builtin.include_vars:
        file: "{{ ifcfg_profile }}"
        name: dns_profile
      delegate_to: localhost
      become: false

    - name: Error handling
      when: dns_profile is undefined
      block:
        - name: Error message
          ansible.builtin.debug:
            msg: "Variable with profile information not defined, check profile file."

        - meta: end_host

    - name: Check if network-scripts directory exists
      ansible.builtin.stat:
        path: "{{ ifcfg_dir }}"
      register: result

    - name: Find all ifcfg files
      when: result is defined and result.stat.isdir | default(false)
      ansible.builtin.find:
        paths: "{{ ifcfg_dir }}"
        patterns: '^ifcfg-[A-Za-z0-9_.:-]+$'
        file_type: file
        use_regex: true
      register: all_ifcfg

    - name: Save list of all ifcfg files (paths)
      ansible.builtin.set_fact:
        all_ifcfg_files: "{{ (all_ifcfg.files | default([])) | map(attribute='path') | list }}"

    - name: Find only ifcfg files (exclude lo/backups)
      when: result is defined and result.stat.isdir | default(false)
      ansible.builtin.find:
        paths: "{{ ifcfg_dir }}"
        patterns: '^ifcfg-[A-Za-z0-9_.:-]+$'
        excludes:
          - '^ifcfg-lo$'
          - '.*\.(bak|old|orig|tmp|rpm(new|save))$'
          - '.*~$'
        file_type: file
        use_regex: true
      register: found_ifcfg

    - name: Save list of ifcfg files (paths)
      ansible.builtin.set_fact:
        ifcfg_files: "{{ (found_ifcfg.files | default([])) | map(attribute='path') | list }}"

    - name: Invalid number of network interfaces
      when: ifcfg_files | length != 1
      block:
        - name: Device will be skipped
          ansible.builtin.debug:
            msg:
              - "{{ inventory_hostname }} will be skipped"
              - "INVALID number of network interfaces found"
              - "Interface counter: '{{ ifcfg_files | length }}'."

        - name: Write hosts lists due to invalid number of NICs
          ansible.builtin.set_fact:
            in_scope: false
            vm_ifcfg_summary: "{{ vm_ifcfg_summary + [{'host': inventory_hostname, 'msg': 'invalid_nics'}] }}"

        - meta: end_host

    - name: Extra check to stop if multiple interfaces are found
      when: ifcfg_files | length != 1
      ansible.builtin.fail:
        msg:
          - "Emergency stop, invalid number of interfaces found"
          - "Interfaces {{ ifcfg_files }}"

    - name: Set inventory zone
      block:
        - name: Set inventory zone
          ansible.builtin.set_fact:
            zone: "{{ inventory_hostname | regex_search('^[^.]+\\.([^.]{2})\\.', '\\1') | join('') }}"

        - name: Get inventory zones
          ansible.builtin.set_fact:
            inventory_zones: "{{ lookup('ansible.builtin.env', 'INVENTORY_ZONES') | split(' ') }}"

        - name: Zone was found and is valid
          when: zone in inventory_zones
          ansible.builtin.set_fact:
            inventory_zone_found: true

        - name: Invalid zone
          when: inventory_zone_found == false
          block:
            - name: Device will be skipped
              ansible.builtin.debug:
                msg:
                  - "{{ inventory_hostname }} will be skipped"
                  - "Either the zone was not found or is invalid."
                  - "Zone found was: '{{ zone }}'."

            - name: Write failed hosts lists due to zone mismatch
              ansible.builtin.set_fact:
                in_scope: false
                vm_ifcfg_summary: "{{ vm_ifcfg_summary + [{'host': inventory_hostname, 'msg': 'invalid_zone'}] }}"

            - meta: end_host

        - name: Mark host in-scope (passed gates)
          when: inventory_zone_found
          ansible.builtin.set_fact:
            in_scope: true

    - name: Process resolv configuration file (detection only)
      when: inventory_zone_found
      block:
        - name: Check resolv.conf
          ansible.builtin.command: "cat {{ resolv_conf_path }}"
          changed_when: false
          register: resolv_result

        - name: Set vars
          when: resolv_result is defined and resolv_result.stdout_lines is defined
          ansible.builtin.set_fact:
            host_resolv_data:
              name: "{{ inventory_hostname }}"
              dns_config: "{{ resolv_result.stdout_lines }}"
              raw_config: "{{ resolv_result.stdout }}"

        - name: Compute resolv.conf nameserver list (same logic as dryrun)
          when: host_resolv_data is defined
          ansible.builtin.set_fact:
            resolv_nameservers: >-
              {{
                host_resolv_data.dns_config
                | select('search', '^nameserver')
                | map('regex_replace', '^nameserver\s+', '')
                | map('trim')
                | list
              }}

        - name: Compute resolv.conf compliance (same logic as dryrun)
          when: host_resolv_data is defined
          ansible.builtin.set_fact:
            resolv_compliant: >-
              {{
                (resolv_nameservers | sort) == (valid_nameservers | map('trim') | sort)
              }}

        - name: Process noncompliant resolv.conf
          when: resolv_compliant is defined and (not resolv_compliant)
          block:
            - name: Find dhclient files globally
              ansible.builtin.find:
                paths:
                  - /etc
                  - /var/lib
                recurse: true
                patterns:
                  - "^dhclient-(eth|ens|enp)[A-Za-z0-9_-]*\\.conf$"
                  - "^dhclient-(eth|ens|enp)[A-Za-z0-9_-]*\\.conf(?:\\.disabled)?$"
                use_regex: true
                file_type: file
              register: global_dhclient_files

            - name: dhclient files were found
              when:
                - global_dhclient_files is defined
                - global_dhclient_files.matched | int > 0
              ansible.builtin.set_fact:
                disable_dhclient: true
                all_dhclient_files: "{{ all_dhclient_files + (global_dhclient_files.files | map(attribute='path') | list | flatten) }}"

            - name: Append non-compliant resolv.conf summary
              ansible.builtin.set_fact:
                vm_resolv_summary: >-
                  {{
                    (vm_resolv_summary | default([]))
                    + [{
                      'host': inventory_hostname,
                      'msg': 'invalid',
                      'nameservers': resolv_nameservers | default([]),
                      'disable_dhclient': disable_dhclient,
                      'all_dhclient_files': (all_dhclient_files | default([]))
                    }]
                  }}

        - name: Append compliant resolv.conf summary
          when: resolv_compliant is defined and resolv_compliant
          ansible.builtin.set_fact:
            vm_resolv_summary: >-
              {{
                (vm_resolv_summary | default([]))
                + [{
                  'host': inventory_hostname,
                  'msg': 'valid',
                  'nameservers': (resolv_nameservers | default([])),
                  'disable_dhclient': disable_dhclient,
                  'all_dhclient_files': (all_dhclient_files | default([]))
                }]
              }}

    - name: Process ifcfg configuration file (detection only)
      when: inventory_zone_found
      block:
        - name: Check ifcfg configuration
          ansible.builtin.slurp:
            src: "{{ ifcfg_files | first }}"
          register: ifcfg_raw

        - name: Build parsed DNS structure from files
          ansible.builtin.set_fact:
            ifcfg_data: "{{ (ifcfg_data | default([])) + [parsed] }}"
          vars:
            text: "{{ ifcfg_raw.content | b64decode }}"
            iface: "{{ (ifcfg_raw.source | regex_search('ifcfg-(.+)$', '\\1')) | default(ifcfg_raw.source) }}"
            bootproto_raw: "{{ text | regex_search('^BOOTPROTO=(.*)$', multiline=True) | default('', true) }}"
            bootproto: "{{ bootproto_raw | regex_replace('^BOOTPROTO=', '') | default('', true) }}"
            peerdns_raw: "{{ text | regex_search('^PEERDNS=(.*)$', multiline=True) | default('', true) }}"
            peerdns: "{{ peerdns_raw | regex_replace('^PEERDNS=', '') | default('', true) }}"
            nameservers: "{{ text | regex_findall('^DNS[0-9]+=(.*)$', multiline=True) | default([], true) }}"
            domains_raw: "{{ text | regex_search('^DOMAIN=(.+)$', multiline=True) | default('', true) }}"
            domains: "{{ domains_raw | regex_replace('\"', '') | default('', true) }}"
            parsed:
              interface: "{{ iface }}"
              path: "{{ ifcfg_raw.source }}"
              bootproto: "{{ bootproto }}"
              peerdns: "{{ peerdns }}"
              nameservers: "{{ nameservers }}"
              domains: "{{ domains }}"

    - name: Evaluate ifcfg configuration (same logic as dryrun)
      when: ifcfg_data is defined
      vars:
        _want_peerdns: "{{ dns_profile['ifcfg']['peerdns'] | lower }}"
        _want_boot: "{{ dns_profile['ifcfg']['bootproto'] | lower }}"
      ansible.builtin.set_fact:
        ifcfg_overall_changes: >-
          {{
            (ifcfg_overall_changes | default([]))
            + [{
                'interface': item.path,
                'change_required': (
                  (item.peerdns | default('', true) | lower) != _want_peerdns
                  or
                  (item.bootproto | default('', true) | lower) != _want_boot
                  or
                  ((item.nameservers | default([], true) | length) > 0)
                )
              }]
          }}
      loop: "{{ ifcfg_data }}"
      loop_control:
        label: "{{ item.path }}"

  tasks:
    - name: Build host change_plan + snapshots (same structure as dryrun)
      when:
        - ifcfg_data is defined
        - host_resolv_data is defined
      block:
        - name: Set variables
          ansible.builtin.set_fact:
            ifcfg_config:
              path: "{{ ifcfg_raw.source }}"
              data: "{{ ifcfg_raw.content | b64decode }}"
            change_plan:
              host: "{{ inventory_hostname }}"
              data: {}

    - name: Check IFCFG and populate change_plan (same logic as dryrun)
      when:
        - change_plan is defined
        - ifcfg_overall_changes is defined
        - (ifcfg_overall_changes | selectattr('change_required') | list | length) > 0
      ansible.builtin.set_fact:
        change_plan: >-
          {{
            change_plan | combine({'data': (ifcfg_overall_changes | first) })
          }}

  post_tasks:
    - name: ifcfg requires change
      when:
        - change_plan is defined and ifcfg_overall_changes is defined
        - (ifcfg_overall_changes | selectattr('change_required') | list | length) > 0
        - change_plan['data']['change_required']
      ansible.builtin.set_fact:
        vm_ifcfg_summary: >-
          {{
            (vm_ifcfg_summary | default([]))
            + [{
              'host': inventory_hostname,
              'msg': 'valid',
              'ifcfg_is': 'invalid',
              'change_plan': change_plan
            }]
          }}

    - name: ifcfg does not require change
      when: change_plan is defined and change_plan['data'] | length == 0
      ansible.builtin.set_fact:
        vm_ifcfg_summary: >-
          {{
            (vm_ifcfg_summary | default([]))
            + [{
              'host': inventory_hostname,
              'msg': 'valid',
              'ifcfg_is': 'valid',
              'change_plan': change_plan
            }]
          }}


# =====================================================================
# PLAY 2: REMEDIATE
# - Only ifcfg + dhclient
# - No resolv.conf writes
# - Reboot only if any change made
# =====================================================================

- name: Remediation - Apply (ifcfg + dhclient only)
  hosts: all
  serial: 1
  become: true
  become_user: root
  gather_facts: no

  tasks:
    - name: Safety: skip out-of-scope hosts
      when: not (in_scope | default(false) | bool)
      ansible.builtin.debug:
        msg: "Skipping {{ inventory_hostname }} (out-of-scope)."

    - name: Safety assert: must have summaries for in-scope hosts
      when: (in_scope | default(false) | bool)
      ansible.builtin.assert:
        that:
          - vm_ifcfg_summary is defined
          - (vm_ifcfg_summary | length) > 0
          - vm_resolv_summary is defined
          - (vm_resolv_summary | length) > 0
        fail_msg: "Safety stop: missing compliance summaries on an in-scope host. Will not remediate."

    - name: Compute remediation flags
      when: (in_scope | default(false) | bool)
      ansible.builtin.set_fact:
        _ifcfg_invalid: "{{ ((vm_ifcfg_summary | first).ifcfg_is | default('')) == 'invalid' }}"
        _dhclient_present: "{{ ((vm_resolv_summary | first).disable_dhclient | default(false)) | bool }}"
        _dhclient_files: "{{ (vm_resolv_summary | first).all_dhclient_files | default([]) }}"
        _ifcfg_path: "{{ ifcfg_config.path | default('') }}"
        _want_boot: "{{ dns_profile['ifcfg']['bootproto'] }}"
        _want_peerdns: "{{ dns_profile['ifcfg']['peerdns'] }}"

    - name: Safety assert: ifcfg path must exist when remediation may touch it
      when:
        - (in_scope | default(false) | bool)
        - _ifcfg_invalid
      ansible.builtin.assert:
        that:
          - _ifcfg_path is defined
          - _ifcfg_path | length > 0
        fail_msg: "Safety stop: ifcfg path is undef_
