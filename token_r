---
- name: Remediation Play
  hosts: all
  become: true
  become_user: root
  gather_facts: no
  pre_tasks:
    - name: Set Global variables
      ansible.builtin.set_fact:
        resolv_conf_path: "/etc/resolv.conf"
        ifcfg_profile: "../configuration/ifcfg.yml"
        ifcfg_dir: "/etc/sysconfig/network-scripts"
        inventory_zone_found: false
        profile_found: false
        vm_ifcfg_summary: []
        dns_configs: []
        all_dhclient_files: []
        disable_dhclient: false
        valid_nameservers: ["1.1.1.1", "2.2.2.2"]

    - name: Reachability check
      ansible.builtin.wait_for_connection:
        timeout: 10
      register: wfc
      ignore_unreachable: true
      failed_when: false

    - name: Block
      when: 
        - wfc is defined and wfc.msg is defined 
        - (wfc.msg | regex_search('timed out|time out|failed to connect|unreachable|connection refused|permission denied', ignorecase=True))
      block:
        - name: Error message
          ansible.builtin.debug:
            msg: "The '{{ inventory_hostname }}' VM is unreachable or authentication failed."

        - name: Write failed hosts lists
          ansible.builtin.set_fact:
            vm_ifcfg_summary: "{{ vm_ifcfg_summary + [{'host': inventory_hostname, 'msg': 'unreachable_vm'}] }}"

        - meta: end_host

    - name: Include DNS variables
      ansible.builtin.include_vars: 
        file: "{{ ifcfg_profile }}"
        name: dns_profile
      delegate_to: localhost
      become: false

    - name: Error handling
      when: dns_profile is undefined
      block:
        - name: Error message
          ansible.builtin.debug: 
            msg: "Variable with profile information not defined, check profile file."

        - name: Stop execution
          meta: end_host

    - name: Check if network-scripts directory exists
      ansible.builtin.stat: 
        path: "{{ ifcfg_dir }}"
      register: result

    - name: Find all ifcfg files
      when: result is defined and result.stat.isdir | default(false)
      ansible.builtin.find:
        paths: "{{ ifcfg_dir }}"
        patterns: '^ifcfg-[A-Za-z0-9_.:-]+$'
        file_type: file
        use_regex: true
      register: all_ifcfg

    - name: Save list of all ifcfg files (paths)
      ansible.builtin.set_fact:
        all_ifcfg_files: "{{ (all_ifcfg.files | default([])) | map(attribute='path') | list }}"

    - name: Find only ifcfg files
      when: result is defined and result.stat.isdir | default(false)
      ansible.builtin.find:
        paths: "{{ ifcfg_dir }}"
        patterns: '^ifcfg-[A-Za-z0-9_.:-]+$'
        excludes:
          - '^ifcfg-lo$' 
          - '.*\.(bak|old|orig|tmp|rpm(new|save))$'
          - '.*~$'
        file_type: file
        use_regex: true
      register: found_ifcfg

    - name: Save list of ifcfg files (paths)
      ansible.builtin.set_fact:
        ifcfg_files: "{{ (found_ifcfg.files | default([])) | map(attribute='path') | list }}"

    - name: Invalid number of network interfaces
      when: ifcfg_files | length != 1
      block:
        - name: Device will be skipped
          ansible.builtin.debug:
            msg: 
              - "{{ inventory_hostname }} will be skipped"
              - "INVALID number of network interfaces found"
              - "Interface counter: '{{ ifcfg_files | length }}'."

        - name: Write hosts lists due to invalid number of NICs
          ansible.builtin.set_fact:
            vm_ifcfg_summary: "{{ vm_ifcfg_summary + [{'host': inventory_hostname, 'msg': 'invalid_nics'}] }}"

        - name: Stopping play
          meta: end_host

    - name: Device with valid number of network interfaces
      when: ifcfg_files | length == 1
      ansible.builtin.debug:
        msg:
          - "Device {{ inventory_hostname }} with valid # of interfaces."
          - "Interface counter: '{{ ifcfg_files | length }}'"
          - "Interface path:  '{{ ifcfg_files | first }}'"
          - "Device will be processed in later tasks."

    - name: Extra check to stop if multiple interfaces are found
      when: ifcfg_files | length != 1
      ansible.builtin.fail:
        msg: 
          - "Emergency stop, invalid number of interfaces found"
          - "Interfaces {{ ifcfg_files }}"

    - name: Set inventory zone
      block:
        - name: Set inventory zone
          ansible.builtin.set_fact:
            zone: "{{ inventory_hostname | regex_search('^[^.]+\\.([^.]{2})\\.', '\\1') | join('') }}"

        - name: Get inventory zones
          ansible.builtin.set_fact:
            inventory_zones: "{{ lookup('ansible.builtin.env', 'INVENTORY_ZONES') | split(' ') }}"

        - name: Zone was found and is valid
          when: zone in inventory_zones
          ansible.builtin.set_fact:
            inventory_zone_found: true

        - name: Invalid zone
          when: inventory_zone_found == false
          block:
            - name: Device will be skipped
              ansible.builtin.debug:
                msg: 
                  - "{{ inventory_hostname }} will be skipped"
                  - "Either the zone was not found or is invalid."
                  - "Zone found was: '{{ zone }}'."

            - name: Write failed hosts lists due to zone mismatch
              ansible.builtin.set_fact:
                vm_ifcfg_summary: "{{ vm_ifcfg_summary + [{'host': inventory_hostname, 'msg': 'invalid_zone'}] }}"

            - name: Stopping play
              meta: end_host

        - name: Device in a valid zone
          when: inventory_zone_found
          ansible.builtin.debug:
            msg:
              - "{{ inventory_hostname }} is in '{{ zone }}' zone."
              - "Device will be processed in later tasks."

    - name: Process resolv configuration file
      when: inventory_zone_found
      block:
        - name: Check resolv.conf
          ansible.builtin.command: "cat {{ resolv_conf_path }}"
          changed_when: no
          register: resolv_result

        - name: Set vars
          when: resolv_result is defined and resolv_result.stdout_lines is defined
          ansible.builtin.set_fact:
            host_resolv_data:
              name: "{{ inventory_hostname }}"
              dns_config: "{{ resolv_result.stdout_lines }}"
              raw_config: "{{ resolv_result.stdout }}"

        - name: Compute resolv.conf compliance
          when: host_resolv_data is defined
          ansible.builtin.set_fact:
            resolv_nameservers: >-
              {{
                host_resolv_data.dns_config 
                | select('search', '^nameserver')
                | map('replace', 'nameserver ', '') 
                | list
              }}
            resolv_compliant: >-
              {{
                (host_resolv_data.dns_config 
                  | select('search', '^nameserver')
                  | map('replace', 'nameserver ', '') 
                  | list)
                == (valid_nameservers | sort)
              }}

        - name: Show resolv.conf compliance
          when: host_resolv_data is defined
          ansible.builtin.debug:
            msg:
              resolv_nameservers: "{{ resolv_nameservers }}"
              resolv_compliant: "{{ resolv_compliant }}"

        - name: Process noncompliant resolv.conf
          when: resolv_compliant is defined and (not resolv_compliant)
          block:
            - name: Find dhclient files globally
              ansible.builtin.find: 
                paths: 
                  - /etc
                  - /var/lib
                recurse: true
                patterns: 
                  - "^dhclient-(eth|ens|enp)[A-Za-z0-9_-]*\\.conf$"
                  - "^dhclient-(eth|ens|enp)[A-Za-z0-9_-]*\\.conf(?:\\.disabled)?$"
                use_regex: true
                file_type: file
              register: global_dhclient_files

            - name: dhclient-<ifname>.conf files in '/' folder were found
              when:
                - global_dhclient_files is defined
                - global_dhclient_files.matched | int > 0
              ansible.builtin.set_fact:
                disable_dhclient: true
                all_dhclient_files: "{{ all_dhclient_files + (global_dhclient_files.files | map(attribute='path') | list | flatten) }}"

            - name: Append non-compliant resolv.conf summary
              ansible.builtin.set_fact:
                vm_resolv_summary: >-
                  {{
                    (vm_resolv_summary | default([]))
                    + [{
                      'host': inventory_hostname, 
                      'msg': 'invalid', 
                      'nameservers': resolv_nameservers | default([]), 
                      'disable_dhclient': disable_dhclient,
                      'all_dhclient_files': (all_dhclient_files | default([]))
                      }]
                  }}

            - name: Show non-compliant resolv.conf summary
              ansible.builtin.debug:
                msg:
                  vm_resolv_summary: "{{ vm_resolv_summary }}"


        - name: Append compliant resolv.conf summary
          when: resolv_compliant is defined and resolv_compliant
          ansible.builtin.set_fact:
            vm_resolv_summary: >-
              {{
                (vm_resolv_summary | default([]))
                + [{
                  'host': inventory_hostname, 
                  'msg': 'valid', 
                  'nameservers': (resolv_nameservers | default([])),
                  'disable_dhclient': disable_dhclient,
                  'all_dhclient_files': (all_dhclient_files | default([]))
                  }]
              }}

        - name: Show compliant resolv.conf summary 
          when: resolv_compliant is defined and resolv_compliant
          ansible.builtin.debug:
            msg:
              vm_resolv_summary: "{{ vm_resolv_summary }}"

    - name: Process ifcfg configuration file
      when: inventory_zone_found
      block:
        - name: Check ifcfg configuration
          ansible.builtin.slurp:
            src: "{{ ifcfg_files | first }}"
          register: ifcfg_raw

        - name: Build parsed DNS structure from files
          ansible.builtin.set_fact:
            ifcfg_data: "{{ (ifcfg_data | default([])) + [parsed] }}"
          vars:
            text: "{{ ifcfg_raw.content | b64decode }}"
            iface: "{{ (ifcfg_raw.source | regex_search('ifcfg-(.+)$', '\\1')) | default(ifcfg_raw.source) }}"
            bootproto_raw: "{{ text | regex_search('^BOOTPROTO=(.*)$', multiline=True) | default('', true) }}"
            bootproto: "{{ bootproto_raw | regex_replace('^BOOTPROTO=', '') | default('', true) }}"
            peerdns_raw: "{{ text | regex_search('^PEERDNS=(.*)$', multiline=True) | default('', true) }}"
            peerdns: "{{ peerdns_raw | regex_replace('^PEERDNS=', '') | default('', true) }}"
            nameservers: "{{ text | regex_findall('^DNS[0-9]+=(.*)$', multiline=True) | default([], true) }}"
            domains_raw: "{{ text | regex_search('^DOMAIN=(.+)$', multiline=True) | default('', true) }}"
            domains: "{{ domains_raw | regex_replace('\"', '') | default('', true) }}"
            parsed:
              interface: "{{ iface }}"
              path: "{{ ifcfg_raw.source }}"
              bootproto: "{{ bootproto }}"
              peerdns: "{{ peerdns }}"
              nameservers: "{{ nameservers }}"
              domains: "{{ domains }}"

    - name: Evaluate ifcfg configuration
      when: ifcfg_data is defined
      vars:
        _want_peerdns: "{{ dns_profile['ifcfg']['peerdns'] | lower }}"
        _want_boot: "{{ dns_profile['ifcfg']['bootproto'] | lower }}"
      ansible.builtin.set_fact: 
        ifcfg_overall_changes: >-
          {{
            (ifcfg_overall_changes | default([]))
            + [{
                'interface': item.path,
                'change_required': (
                  (item.peerdns | default('', true) | lower) != _want_peerdns
                  or
                  (item.bootproto | default('', true) | lower) != _want_boot
                  or
                  ((item.nameservers | default([], true) | length) > 0)
                ) 
              }]
          }}
      loop: "{{ ifcfg_data }}"
      loop_control:
        label: "{{ item.path }}"

  tasks:
    - name: Device in a valid zone
      when: ifcfg_data is defined and host_resolv_data
      block:
        - name: Set variables
          ansible.builtin.set_fact:
            resolv_config:
              data: "{{ host_resolv_data.raw_config }}"
              path: "{{ resolv_conf_path }}"
            ifcfg_config:
              path: "{{ ifcfg_raw.source }}"
              data: "{{ ifcfg_raw.content | b64decode }}"
            change_plan: 
              host: "{{ inventory_hostname }}"
              data: {}

        - name: Show resolv_config variables
          ansible.builtin.debug:
            msg:
              resolv_config: "{{ resolv_config }}"
              ifcfg_config: "{{ ifcfg_config }}"
              change_plan: "{{ change_plan }}"


    - name: Check IFCFG
      when: 
        - change_plan is defined
        - ifcfg_overall_changes is defined
        - (ifcfg_overall_changes | selectattr('change_required') | list | length) > 0
      ansible.builtin.set_fact: 
        change_plan: >-
          {{
            change_plan | combine({'data': (ifcfg_overall_changes | first) }) 
          }}

  post_tasks:
    - name: ifcfg requires change
      when: 
       - change_plan is defined and ifcfg_overall_changes is defined
       - (ifcfg_overall_changes | selectattr('change_required') | list | length) > 0
       - change_plan['data']['change_required']
      ansible.builtin.set_fact:
        vm_ifcfg_summary: >-
          {{ (vm_ifcfg_summary | default([])) 
            + [{
              'host': inventory_hostname, 
              'msg': 'valid', 
              'ifcfg_is': 'invalid', 
              'change_plan': change_plan 
              }] 
          }}

    - name: ifcfg does not require change
      when: change_plan is defined and change_plan['data'] | length == 0 
      ansible.builtin.set_fact:
        vm_ifcfg_summary: >-
          {{ (vm_ifcfg_summary | default([])) 
            + [{
              'host': inventory_hostname, 
              'msg': 'valid', 
              'ifcfg_is': 'valid', 
              'change_plan': change_plan 
              }] 
          }}

    - name: Set final summary
      ansible.builtin.set_fact:
        final_summary:
          vm: "{{ inventory_hostname }}"
          ifcfg: "{{ vm_ifcfg_summary }}"
          resolv: "{{ vm_resolv_summary }}"
          
    - name: Show final summary
      debug:
        msg: "{{ final_summary }}"

    - name: Implement change - process dhclient files if present
      when: ( 
              ((final_summary['ifcfg'] | first).ifcfg_is | default('')) == 'invalid' or
              ((final_summary['resolv'] | first).msg | default('')) == 'invalid' and
              (final_summary['resolv'] | first).disable_dhclient | bool 
            )
      block: 
        - debug:
            msg: 
              - "Action plan for: {{ inventory_hostname }}"
              - "Disable dhclient files: {{ (final_summary['resolv'] | first).all_dhclient_files }}"

    - name: Implement change - IFCFG and resolv config are invalid
      when: ((final_summary['ifcfg'] | first).ifcfg_is | default('')) == 'invalid'
      block: 
        - debug:
            msg: 
              - "Action plan for: {{ inventory_hostname }}"
              - "Update ifcfg: {{ (final_summary['ifcfg'] | first).change_plan.data.interface | basename }}"
              - "Restart network manager"
              - "Reboot VM"

    - name: Disable dhconf files
      # when: 
      #   - ((final_summary['ifcfg'] | first).ifcfg_is | default('')) == 'invalid'
      #   - (final_summary['resolv'] | first).all_dhclient_files | length > 0
      ansible.builtin.include_tasks: disable_dhclient.yml
      loop: "{{ (final_summary['resolv'] | first).all_dhclient_files }}"

    - name: Restart process and reboot VM
      # when: 
      #   - ((final_summary['ifcfg'] | first).ifcfg_is | default('')) == 'invalid'
      #   - (final_summary['resolv'] | first).all_dhclient_files | length > 0
      ansible.builtin.include_tasks: restart_reboot.yml

    # - name: Implement change - IFCFG and resolv config are invalid
    #   when: ((final_summary['resolv'] | first).msg | default('')) == 'invalid'
    #   block: 
    #     - debug:
    #         msg: 
    #           - "Action plan for: {{ inventory_hostname }}"
    #           - "Restart network manager"
    #           - "Reboot VM"

    #     - name: Change ifcfg file
    #       ansible.builtin.include_tasks: change_ifcfg.yml
    #       vars: 
    #         ifcfg_file: "{{ (final_summary['ifcfg'] | first).change_plan.data.interface }}"

    #     - name: Disable dhclient files
    #       ansible.builtin.include_tasks: disable_dhclient.yml
    #       loop: "{{ (final_summary['resolv'] | first).all_dhclient_files }}"

    #     - name: Restart process and reboot VM
    #       ansible.builtin.include_tasks: restart_reboot.yml

    # - name: Implement change
    #   when: 
    #     - (final_summary['ifcfg'] | first).change_plan.data | length > 0
    #     - not (final_summary['resolv'] | first).disable_dhclient
    #   block: 
    #     - debug:
    #         msg: 
    #           - "Action plan for: {{ final_summary['vm'] }}"
    #           - "Update ifcfg: {{ (final_summary['ifcfg'] | first).change_plan.data.interface | basename }}"
    #           - "Restart network manager"
    #           - "Reboot VM"

    #     - name: Change ifcfg file
    #       ansible.builtin.include_tasks: change_ifcfg.yml
    #       vars: 
    #         ifcfg_file: "{{ (final_summary['ifcfg'] | first).change_plan.data.interface }}"

    #     - name: Restart process and reboot VM
    #       ansible.builtin.include_tasks: restart_reboot.yml
          
    - name: No change required
      when: 
        - (final_summary['ifcfg'] | first).change_plan.data | length == 0
        - not (final_summary['resolv'] | first).disable_dhclient
      block: 
        - debug:
            msg: 
              - "Action plan for: {{ final_summary['vm'] }}"
              - "No changes required."





